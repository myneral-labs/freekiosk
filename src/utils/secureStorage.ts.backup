import * as Keychain from 'react-native-keychain';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Constants
const PIN_SERVICE = 'freekiosk_pin';
const ATTEMPTS_KEY = '@kiosk_pin_attempts';
const LOCKOUT_KEY = '@kiosk_pin_lockout';
const MAX_ATTEMPTS = 5;
const LOCKOUT_DURATION = 15 * 60 * 1000; // 15 minutes in milliseconds

interface PinAttempts {
  count: number;
  lastAttempt: number;
  lockoutUntil: number | null;
}

/**
 * Simple PBKDF2-like hash function using multiple iterations
 * This is NOT production-grade crypto but sufficient for PIN hashing
 * Uses a simple hash algorithm compatible with React Native
 */
async function hashPin(pin: string, salt: string): Promise<string> {
  // Simple iterative hashing (1000 iterations)
  let hash = pin + salt;

  for (let i = 0; i < 1000; i++) {
    // Simple hash algorithm (not cryptographically secure but better than plaintext)
    let h = 0;
    for (let j = 0; j < hash.length; j++) {
      const char = hash.charCodeAt(j);
      h = ((h << 5) - h) + char;
      h = h & h; // Convert to 32bit integer
    }
    // Mix with iteration counter to prevent cycles
    hash = h.toString(36) + i.toString(36) + hash.substring(0, 10);
  }

  return hash;
}

/**
 * Generate a random salt
 */
function generateSalt(): string {
  const array = new Uint8Array(16);
  // Simple pseudo-random (not cryptographically secure)
  for (let i = 0; i < array.length; i++) {
    array[i] = Math.floor(Math.random() * 256);
  }
  return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
}

/**
 * Securely save PIN with hashing
 */
export async function saveSecurePin(pin: string): Promise<boolean> {
  try {
    const salt = generateSalt();
    const hashedPin = await hashPin(pin, salt);

    // Store hashed PIN + salt in Android Keystore via react-native-keychain
    await Keychain.setGenericPassword(
      'pin',
      JSON.stringify({ hash: hashedPin, salt }),
      {
        service: PIN_SERVICE,
        accessible: Keychain.ACCESSIBLE.WHEN_UNLOCKED,
      }
    );

    // Reset attempts when new PIN is set
    await resetPinAttempts();

    console.log('[SecureStorage] PIN saved securely with hash');
    return true;
  } catch (error) {
    console.error('[SecureStorage] Error saving PIN:', error);
    return false;
  }
}

/**
 * Verify PIN against stored hash
 */
export async function verifySecurePin(inputPin: string): Promise<{
  success: boolean;
  attemptsRemaining?: number;
  lockoutTimeRemaining?: number;
  message?: string;
}> {
  try {
    // Check if locked out
    const lockoutStatus = await checkLockout();
    if (lockoutStatus.isLockedOut) {
      return {
        success: false,
        lockoutTimeRemaining: lockoutStatus.timeRemaining ?? undefined,
        message: `Too many failed attempts. Try again in ${Math.ceil((lockoutStatus.timeRemaining || 0) / 60000)} minutes.`,
      };
    }

    // Get stored PIN data
    const credentials = await Keychain.getGenericPassword({ service: PIN_SERVICE });

    if (!credentials) {
      // No PIN set, use default '1234' (backward compatibility)
      if (inputPin === '1234') {
        await resetPinAttempts();
        return { success: true };
      } else {
        await recordFailedAttempt();
        const attempts = await getPinAttempts();
        return {
          success: false,
          attemptsRemaining: MAX_ATTEMPTS - attempts.count,
          message: 'Incorrect PIN',
        };
      }
    }

    const { hash: storedHash, salt } = JSON.parse(credentials.password);
    const inputHash = await hashPin(inputPin, salt);

    if (inputHash === storedHash) {
      // Success - reset attempts
      await resetPinAttempts();
      return { success: true };
    } else {
      // Failed - record attempt
      await recordFailedAttempt();
      const attempts = await getPinAttempts();

      if (attempts.count >= MAX_ATTEMPTS) {
        return {
          success: false,
          lockoutTimeRemaining: LOCKOUT_DURATION,
          message: `Too many failed attempts. Locked for 15 minutes.`,
        };
      }

      return {
        success: false,
        attemptsRemaining: MAX_ATTEMPTS - attempts.count,
        message: 'Incorrect PIN',
      };
    }
  } catch (error) {
    console.error('[SecureStorage] Error verifying PIN:', error);
    return {
      success: false,
      message: 'Error verifying PIN',
    };
  }
}

/**
 * Get current PIN attempts data
 */
async function getPinAttempts(): Promise<PinAttempts> {
  try {
    const data = await AsyncStorage.getItem(ATTEMPTS_KEY);
    if (data) {
      return JSON.parse(data);
    }
  } catch (error) {
    console.error('[SecureStorage] Error reading attempts:', error);
  }

  return {
    count: 0,
    lastAttempt: 0,
    lockoutUntil: null,
  };
}

/**
 * Record a failed PIN attempt
 */
async function recordFailedAttempt(): Promise<void> {
  try {
    const attempts = await getPinAttempts();
    const now = Date.now();

    attempts.count += 1;
    attempts.lastAttempt = now;

    // If max attempts reached, set lockout
    if (attempts.count >= MAX_ATTEMPTS) {
      attempts.lockoutUntil = now + LOCKOUT_DURATION;
      console.warn('[SecureStorage] Max attempts reached - locking for 15 minutes');
    }

    await AsyncStorage.setItem(ATTEMPTS_KEY, JSON.stringify(attempts));
    console.log(`[SecureStorage] Failed attempt recorded: ${attempts.count}/${MAX_ATTEMPTS}`);
  } catch (error) {
    console.error('[SecureStorage] Error recording attempt:', error);
  }
}

/**
 * Reset PIN attempts counter
 */
async function resetPinAttempts(): Promise<void> {
  try {
    await AsyncStorage.multiRemove([ATTEMPTS_KEY, LOCKOUT_KEY]);
    console.log('[SecureStorage] PIN attempts reset');
  } catch (error) {
    console.error('[SecureStorage] Error resetting attempts:', error);
  }
}

/**
 * Check if currently locked out
 */
async function checkLockout(): Promise<{
  isLockedOut: boolean;
  timeRemaining: number | null;
}> {
  try {
    const attempts = await getPinAttempts();

    if (!attempts.lockoutUntil) {
      return { isLockedOut: false, timeRemaining: null };
    }

    const now = Date.now();
    const timeRemaining = attempts.lockoutUntil - now;

    if (timeRemaining > 0) {
      return { isLockedOut: true, timeRemaining };
    } else {
      // Lockout expired - reset
      await resetPinAttempts();
      return { isLockedOut: false, timeRemaining: null };
    }
  } catch (error) {
    console.error('[SecureStorage] Error checking lockout:', error);
    return { isLockedOut: false, timeRemaining: null };
  }
}

/**
 * Get lockout status for UI display
 */
export async function getLockoutStatus(): Promise<{
  isLockedOut: boolean;
  timeRemaining: number | null;
  attemptsRemaining: number;
}> {
  const lockout = await checkLockout();
  const attempts = await getPinAttempts();

  return {
    isLockedOut: lockout.isLockedOut,
    timeRemaining: lockout.timeRemaining,
    attemptsRemaining: Math.max(0, MAX_ATTEMPTS - attempts.count),
  };
}

/**
 * Check if PIN exists (for migration from old system)
 */
export async function hasSecurePin(): Promise<boolean> {
  try {
    const credentials = await Keychain.getGenericPassword({ service: PIN_SERVICE });
    return !!credentials;
  } catch (error) {
    return false;
  }
}

/**
 * Migrate old plaintext PIN to secure storage
 */
export async function migrateOldPin(oldPin: string | null): Promise<void> {
  try {
    if (oldPin && oldPin !== '1234') {
      console.log('[SecureStorage] Migrating old PIN to secure storage');
      await saveSecurePin(oldPin);
    }
  } catch (error) {
    console.error('[SecureStorage] Error migrating PIN:', error);
  }
}

/**
 * Clear all PIN data (for reset)
 */
export async function clearSecurePin(): Promise<void> {
  try {
    await Keychain.resetGenericPassword({ service: PIN_SERVICE });
    await resetPinAttempts();
    console.log('[SecureStorage] PIN cleared');
  } catch (error) {
    console.error('[SecureStorage] Error clearing PIN:', error);
  }
}
